<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>swagon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的代码很烂">
<meta property="og:type" content="website">
<meta property="og:title" content="swagon">
<meta property="og:url" content="yoursite.com/page/3/index.html">
<meta property="og:site_name" content="swagon">
<meta property="og:description" content="我的代码很烂">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="swagon">
<meta name="twitter:description" content="我的代码很烂">
  
    <link rel="alternative" href="/atom.xml" title="swagon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">swagon</a></h1>
		</hgroup>

		
		<p class="header-subtitle">原谅我不堪回首的过去</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">swagon</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">swagon</h1>
			</hgroup>
			
			<p class="header-subtitle">原谅我不堪回首的过去</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-学会看xcode文档" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/17/学会看xcode文档/" class="article-date">
  	<time datetime="2015-05-17T04:49:11.000Z" itemprop="datePublished">5月 17 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学会看Xcode文档">学会看Xcode文档</h2><p>前面我们讲Xcode的文档结构是在介绍如何能够快速定位到你要找的内容。但是很多人的问题可能是一开始就根本不知道要读什么。</p>
<p>这里我们就介绍自学iOS开发应该遵循或者说我们推荐的必读文档的阅读顺序。</p>
<p>阅读顺序：</p>
<p>《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》<br>《Your First iOS App》<br>《Your Second iOS App: Storyboards》<br>《Your Third iOS App: iCloud》<br>《iOS Technology Overview》<br>《iOS Human Interface Guidelines》<br>《Learning Objective-C: A Primer》和《Programming with Objective-C》<br>《iOS App Programming Guide》<br>《View Programming Guide for iOS》和《View Controller Programming Guide for iOS》<br>《Table View Programming Guide for iOS》<br>首先应该看的是Getting Started里面的《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》（中英文版本皆有，苹果官方的翻译）。这个文档讲的很浅，但是是建立概念的文档，你以后在开发里面经常遇到的概念，在这里都有包含，特别注意是，这个文档看起来简单，但是每页下面的相关文章，不是选读，都是必读。</p>
<p>即使是很多做了iOS开发很久的同学，其实也有很多概念上的误解，现代程序开发越来越简单，工具越来越强大，往往有些误解也可以继续前行，但是实际上不建立扎实的基础是很吃亏的，往往后面理解和解决一个不难解决小问题都要付出很多辛苦。</p>
<p>阅读这个文档的目的和检测标准是，以后你看到iOS开发中的基本概念，都大致所有了解。</p>
<p>读完《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》后，应该去看Your XXX iOS App系列这个系列不是什么很难的文章，你也不必着急先去学习Objective-C，学什么C语言就更不要着急。我推荐的学习方法是有成就的逐步学习法。在学习系统体系架构、Objective-C之前，你可以先按照文档写一个全天下最简单的App，完成学习过程中第一个里程碑。在这个过程中不用担心有什么疑问，有什么不懂，先照着做就是。</p>
<p>阅读这三个文档的目的和检测标准是，把这三个Demo App做出来在模拟器上跑起来。</p>
<p>在这个过程中，你对开发工具的基本认识就建立起来了，也有了成就感，去了魅（就是消除了对iOS开发的神秘感）。</p>
<p>再往下，建议你去看《iOS Technology Overview》（iOS技术概览），iOS不是一个技术，而是一堆技术，前一篇讲到文档导航区域的分类，框架分类的时候，我说不细讲的原因就在于此，你要做一个动画应该用Core Animation还是OpenGL？你要做一些文本相关操作应该用Core Text还是什么，就是看这里。</p>
<p>学习现代的程序开发，语言和框架并重。我们Tiny4Cocoa叫做这个名字的原因就是，iOS/Mac开发者的代表往往就是这个Cocoa框架，就是这个SDK。大多数你所需要的功能都躺在框架里面，你知道框架的结构，你才知道怎么去寻找相关的技术资料。</p>
<p>阅读这个文档的目的和检测标准是，遇到具体问题，知道应该去看哪方面的文档。</p>
<p>再下来，建议阅读的是《iOS Human Interface Guidelines》，Mac/iOS平台虽然也是百花齐放各类程序、App都有，但是总体看来，大多数优秀App的UI看起来都和整个系统很协调。这和Windows以及很多其他平台完全不同。这是为什么呢？</p>
<p>很大程度就归功于《Human Interface Guidelines》文化，所谓Human Interface Guidelines就是用户界面的规范，在苹果它还专门有一个缩写叫做HIG，是天条一样的东西。所有的App都推荐遵循HIG，遵循了HIG，你做的东西用户看起来就会觉得和整个系统很协调。即使是你要做一些创新的设计，你势必会打破HIG的限制，但是你这个时候仍旧应该遵循HIG的精神。</p>
<p>此外，你阅读HIG的很重要一点是了解整个UI结构和UE行为的逻辑机理，这样才能在你设计界面的时候有所依据。</p>
<p>阅读这个文档的目的和检测标准是，看到任何一个App，你可以知道它的任何一个UI是系统控件，还是自定义控件，它的层次关系等等。</p>
<p>《Learning Objective-C: A Primer》是非常初级和简单的入门，适合先阅读。《Programming with Objective-C》超微复杂一点点，适合后阅读。</p>
<p>一般人建议先学习语言，我反之建议先做了一个App，然后再学习语言。原因有几个，首先现代开发工具，往往不是用来开发控制台程序的，上来就会有框架，光懂语言不会使用IDE，甚至可能会更麻烦。再其次就是，其实现代语言发展到了面向对象以后，库往往比语言更复杂，更重要，或者说更多的时候，我们是在学习库，而不是语言，语言只是库的一个载体。</p>
<p>比如，Delegate和Block等等都和Cocoa的UI异步机制关系紧密，光看代码，这些语言元素非常难以学习，也完全不知道其意义在哪里。</p>
<p>阅读这个文档的目的和检测标准是，看得懂基本的Objective-C代码，方便后面的学习和阅读各种示例代码。</p>
<p>《iOS App Programming Guide》基本上介绍的就是开发一个App的完整流程，包括App的生命周期、休眠、激活等等，里面介绍的细节颇多。正式开发第一个上线的App之前必看。或者开发了一个App，临到提交前必看才文档。</p>
<p>阅读这个文档的目的和检测标准是，了解全部流程和很多细节问题。</p>
<p>《View Programming Guide for iOS》和《View Controller Programming Guide for iOS》非常重要。View是整个图形界面里面最重要的概念。所有的图形、界面绘制都基于View。你看到的一切复杂的用户界面，就是各种不同的View的组合堆叠。</p>
<p>View Controller是View和某种逻辑在一起的组合，本质上这种组合不是必须的，但是是大大降低编程复杂度的一种设计。很多人不懂什么是View什么是View Controller，这样写起代码来就很痛苦。</p>
<p>阅读这个文档的目的和检测标准是，深刻理解什么是View，什么是View Controller，理解什么情况用View，什么情况用View Controller。</p>
<p>UITableView是最重要的一个控件，是最常用的UI界面元素。在UICollectionView出现之前，大量的内容列表展示的自定义控件都是基于UITableView，比如很多书架、图片Grid其实都是UITableView做的。</p>
<p>所以《Table View Programming Guide for iOS》非常重要，一定要好好阅读。</p>
<p>阅读这个文档的目的和检测标准是，深刻理解UITableView／UITableViewController的理论和使用方法。</p>
<p>我推荐的必读文档就这么多，仔细看的话，最多也就是今天就看完了。学习一个东西，如果有一点点耐心，有正确的方法其实不难，不是说脑子非要很聪明，大多数人都可以做到一个星期就学会iOS开发，其实就是读完这些文档，大多数人就会了。</p>
<p>就像我强调了无数次，阅读英文文档不难，我自己从当年看英文文档非常吃力，必须查词典开始，认真的看英文文档，不会就查词典，一个多月过去，读英文文档就完全不需要查词典了。</p>
<p>我们公司主程 @sycx 老师，也说他原来英语也很不好，甚至现在英语仍旧很烂，但是看英文文档完全没有问题，也就是几个星期的认真学习以后就突破了。</p>
<p>其实学习iOS也如此。当然我不是说你看懂这10组文档就再也不用看别的了。而是说，如果你看懂了这10组文档，你就从初学者，或者是虽然会写一些程序，但是对iOS其实还不懂的状态，变成了一个入门者。</p>
<p>我不希望这个文章可以一句一句的帮你学会iOS是什么，这个文章的目的是帮你快速入门。一旦你入门了，你再遇到问题该看什么，你就不需要我讲了，你自己就知道了。一旦入门了，你就会发现，Xcode里面别的文档讲的内容虽然不同，但是结构你已经很清楚了，你学习起来很方便。<br><strong><br>阅读本文的目的和检测标准是，遇到问题，知道看什么文档，想提升自己技术的时候，知道按照什么脉络自己组织阅读</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/13/内存管理/" class="article-date">
  	<time datetime="2015-05-13T03:45:02.000Z" itemprop="datePublished">5月 13 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内存管理">内存管理</h1><h2 id="创建一个对象所作的操作">创建一个对象所作的操作</h2><p>首先这里会涉及到一个堆和栈的感念，系统已知数据类型是保存在堆中，如果要程序员自动定义的类型则是保存在栈当中，因为程序不知道为我们分配具体多大的内存空间</p>
<p>创建一个对象所作的操作<br>1.变量类型已知，分配就在栈上，如果是未知类型（如Person），需要自己申请的， 这样的就会分配在堆中<br>2.栈的入栈操作是压栈，所以栈底的内存地址是最大的，越往栈顶内存地址越小，堆地址从低内存地址向高内存地址增长</p>
<pre><code><span class="name">Person</span> *<span class="atom">p</span>=[[<span class="name">Person</span> <span class="atom">alloc</span>] <span class="atom">init</span>];
</code></pre><ol>
<li>分配内存空间，对应alloc方法;</li>
<li>初始化成员变量，对应init方法;</li>
<li>返回堆空间的地址到栈上面;</li>
<li>内存管理原则(配对原则):只要出现了new,alloc,retain,就一定要出现一个release,autorelease</li>
</ol>
<h3 id="属性">属性</h3><ol>
<li>管理范围：任何继承NSObject的对象都要进行内存管理，普通对象是存放在栈中的（栈会自动回收），所以不需要进行内存管理；</li>
<li>系统判断对象怎么回收：引用计数器（被引用的次数），操作对象的引用计数器（alloc,new,copy默认为<strong>1</strong>） retianCount当前引用计数器的值</li>
<li>property可以生成Get和Set方法：<br><strong>retian</strong>：release旧的值(-1)，retian新值（+1） oc对象类型<br><strong>assgin</strong>:直接赋值<br><strong>copy</strong>:release旧值，Copy新值<br><strong>setter,getter</strong>:setter方法要带<strong>冒号</strong>，一般用在bool类型<br>在.h文件中，用@class,在.中使用#import<br>出现循环引用，可以一段用retain，另一端用assign</li>
</ol>
<p>野指针也可能可以访问到的原因：（被系统回收的对象叫做僵尸对象）xcode为了提高编码效率，不会实时检测僵尸对象,如果要实时检测：Edit Scheme-&gt; enable zoombie objects 耗性能</p>
<ul>
<li><strong>野指针</strong>：在手机中可能出现闪退,对象的retainCount为0时，调用对象的retain方法无法让对象可以复活</li>
<li><strong>内存泄露</strong>：(1)对象的retainCount！=0，就一直存在内存中，不使用的对象，一直存在内存中，没有被销毁。<br>(2)p=nil操作在，对象的retainCount&gt;0的情况下，<code>[nil release]</code></li>
</ul>
<p>避免野指针：确定当前作用域中的对象已经不再被使用，为了防止野指针，不使用的指针变量赋值为<code>nil</code></p>
<p>对象被销毁会调用dealloc函数</p>
<h2 id="多个对象的内存管理">多个对象的内存管理</h2><ul>
<li>为了让一个对象的方法和属性(另外一个对象)都能用，如果不是同一个对象的时候  调用set的时候先释放掉之前的存的对象，然后retain,在dealloc的时候释放掉</li>
</ul>
<h2 id="自动释放池">自动释放池</h2><ul>
<li>autorelease就会放到释放池中，池中存放的是地址，过了大括号就会释放对象</li>
<li>只有在autoreleasepool中调用autorelease才能把对象放到池中</li>
<li>一个对象自动释放两次，会产生什么情况，出了大括号会出现野指针</li>
<li>autoreleasepool嵌套，对象调用autorelease什么时候销毁,在哪调用就在哪里销毁</li>
<li>Person *p这样定义是会有地址存在的（相当于野指针）)，不是nil</li>
<li>创建对象不能马上调用release，所以可以调用autorelease，然后让释放池管理对</li>
<li><code>[[self alloc] init]</code>注意这个坑  </li>
</ul>
<p>使用情况如下</p>
<ul>
<li>提供一个快速给外面访问的方法；</li>
<li>一个对象在创建后不能马上释放，让他在释放池中释放 </li>
</ul>
<h2 id="ARC机制">ARC机制</h2><p>iphone4,iOS4.3之后的产品出现ARC机制<br>编译特性 :dealloc中不能调用[super dealloc] ,编译时加上释放代码</p>
<ul>
<li>强指针：只要有强指针指向一个对象，系统就不会回收这个对象，只要没有强指针指向，就立即</li>
<li>弱指针：用完之后复制为nil,原来就会被回收，局部变量会自动回收</li>
<li>循环引用：一端用Strong,一端用__weak</li>
</ul>
<h2 id="Block：本质还是结构体:用于保存代码">Block：本质还是结构体:用于保存代码</h2><ol>
<li>block 只是 Objective-C 对<strong>闭包的实现</strong> ,block 本身也是一个 Objective-C 对象，声明一个结构体，结构体内部调用定义的函数，有个值描述当前block, clang -rewrite-objc</li>
<li>定义<code>void(^myblock)()=^{};</code>  指向函数的指针；block默认不能修改局部变量（要修改要加上__block），全局变量是可以修改</li>
<li>使用Typedef定义block类型 typedef int (^myblock)(int,int)</li>
<li>根据Block在内存中的位置分为三种类型：NSGlobalBlock，NSStackBlock, NSMallocBlock。<br><strong>NSGlobalBlock</strong>:blk1放到了text代码段<br><strong>NSStackBlock</strong>:有拷贝外部变量到栈上，拷贝的是值的副本（是一个常量，不能修改它的值）， 加上__block修身符之后，就会拷贝这个对象的地址?<br><strong>NSMallocBlock</strong>：位于堆内存。</li>
<li>Block不仅实现函数的功能，还能携带函数的执行环境。</li>
<li>Copy block（会复制到堆中）：有时候是需要block的生命周期长于一开始的stack，而block2被移动到heap中，很可能生命周期会长于stack，所以，shared也被复制到了heap中，<a href="http://www.tanhao.me/pieces/310.html/" title="Title" target="_blank" rel="external">参考文档:老谭笔记</a>，在block中调用<code>[block2 release]</code> ,对象会被销毁</li>
<li>而对于copy到heap中的block 再copy时，行为同普通对象retain一样，会使引用计数+1</li>
<li>block中使用的普通变量（int， char *）导入是const copy。普通对象则会retain。__block 类型变量则什么不做，只是保存一个指针，全局变量也只是保存一个简单的指针    </li>
<li>我们发现原来 <strong>静态变量</strong> 是通过指针传递<a href="https://www.zybuluo.com/MicroCai/note/57603" target="_blank" rel="external">block和变量的内存管理</a>， __block的真身：实质是传递了指针</li>
<li><a href="http://blog.csdn.net/ljianhui/article/details/21666327" target="_blank" rel="external">内存空间分段</a><br><strong>bss</strong>:是指那些没有初始化的和初始化为0的全局变量,占内存空间，但是不占文件空间<br><strong>data</strong>:data指那些初始化过（非零）的非const的全局变量，以上两者都占<br><strong>rodata</strong>的意义同样明显，ro代表read only，即只读数据(const)，多个进程间是共享</li>
</ol>
<ol>
<li>id的定义：<code>typedef struct objc_object {  
Class isa;
} *id;</code><br>Class的定义：<code>typedef struct objc_class *Class;
struct objc_class {
Class isa;  //指向对象类型  
Class super_class; //指向父类的
const char *name; //类名
long version; //类的版本信息,默认为0
long info; //供运行期使用的一些位标识。
long instance_size; //类的实例变量大小
struct objc_ivar_list *ivars; //成员变量的数组
struct objc_method_list **methodList; //方法定义的数组，注意这里是“**”
struct objc_cache; //指向最近使用的方法，用于方法调用的优化.
struct objc_protocol_list *protocols; //协议的数组  
}</code><br><strong>methodList</strong>是指针的指针，所以可以通过修改该指针指向的指针的地址，来动态增加方法，这也是 Category 的实现原理<br><strong>objc_cache</strong>：为了优化方法调用速度，就将调用过的一些方法缓存到到 objc_cache 中<br>此结构体存放类的 <strong>元数据</strong>（metadata)<br>对象所属的类型（即 isa 指针所指向的对象类型）是另一个类，叫做 <strong>元类</strong>（metaclass)，类方法就定义在这个地方 ，类是元类的实例</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-View的生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/13/View的生命周期/" class="article-date">
  	<time datetime="2015-05-13T02:42:37.000Z" itemprop="datePublished">5月 13 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="View">View</h2><h3 id="生命周期">生命周期</h3><ol>
<li>第一次访问UIViewController的view时，view为nil，然后就会调用loadView方法创建view</li>
<li>view创建完毕后会调用viewDidLoad方法进行界面元素的初始化</li>
<li>当内存警告时，系统可能会释放UIViewController的view，将view赋值为nil，并且调用viewDidUnload方法</li>
<li>当再次访问UIViewController的view时，view已经在3中被赋值为nil，所以又会调用loadView方法重新创建view</li>
<li>view被重新创建完毕后，还是会调用viewDidLoad方法进行界面元素的初始化</li>
<li>viewDidUnload方法时，只是释放了view，并没有释放UIViewController，所以并不会调用dealloc方法。即viewDidUnload和dealloc方法并没有任何关系，dealloc方法只会在UIViewController被释放的时候调用<br>loadView-&gt;viewDidLoad-&gt;viewDidUnload(内存警告)-&gt;viewWillDisappear-&gt;viewDidDisappear-&gt;viewWillAppear-&gt;viewDidAppear</li>
</ol>
<h3 id="appdelegate生命周期">appdelegate生命周期</h3><ol>
<li>application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。</li>
<li>applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。</li>
<li>applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。</li>
<li>applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。</li>
<li>applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。</li>
<li>applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。<br>顺序如下:<br>didFinishLaunchingWithOptions<br>applicationDidBecomeActive<br>applicationWillResignActive<br>applicationDidEnterBackground<br>applicationWillEnterForeground<br>applicationDidBecomeActive 进入前台后被激活</li>
</ol>
<p>view在uiviewController生命周期  </p>
<ul>
<li>(void)viewDidLoad；  </li>
<li>(void)viewDidUnload；  </li>
<li>(void)viewWillAppear:(BOOL)animated；  </li>
<li>(void)viewDidAppear:(BOOL)animated；  </li>
<li>(void)viewWillDisappear:(BOOL)animated；  </li>
<li>(void)viewDidDisappear:(BOOL)animated； </li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-核心动画" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/13/核心动画/" class="article-date">
  	<time datetime="2015-05-13T02:29:31.000Z" itemprop="datePublished">5月 13 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="核心动画">核心动画</h2><p>创建基础动画，<br>设置keypath,起始位置,结束位置<br>设置属性，<br>加入到图层中</p>
<p>关键帧动画，可以设置一条路线，路线添加到value属性然后实现</p>
<p>转场动画</p>
<p>self.iconView.image=[UIImage imageNamed:fileName];<br>    CATransition *anmi=[CATransition animation];<br>    anmi.type=@”pageCurl”;<br>    anmi.subtype=kCATransitionFromLeft;<br>    anmi.duration=0.5;<br>    anmi.startProgress=0.8;<br>    anmi.endProgress=0.9;<br>    [self.iconView.layer addAnimation:anmi forKey:nil];</p>
<p>组合动</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-面试准备" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/12/面试准备/" class="article-date">
  	<time datetime="2015-05-12T04:01:14.000Z" itemprop="datePublished">5月 12 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="面试准备">面试准备</h2><h3 id="TCP与UDP">TCP与UDP</h3><p>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<ol>
<li>三次握手：第一次：甲 – 乙，乙反应<br>第二次：乙反应正确，乙 – 甲，第三次：甲正确反应，成功<br>如果乙听到了甲说的话，那么第一次对话成功，接下来进行第二次对话。第二次对话：<br>如果乙听到了甲的话，做出了正确的应答，并且还进行了反问：我吃饭了，你呢？那么第二次握手成功。<br>通过前两次对话证明了乙能够听懂甲说的话，并且能做出正确的应答。<br>接下来进行第三次对话。第三次对话：<br>如果甲也做出了正确的应答：我也吃了。那么第三次对话成功，两人已经建立起了顺畅的沟通渠道，接下来开始持续的聊天。</li>
<li>指针与地址的区别</li>
<li>进程和线程的区别：程序运行的基本单元，线程只是一个进程中的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉  但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li>
<li>内存管理：你弄出来，你要负责</li>
<li>什么是KVC和KVO？答：就是一种通过字符串去间接操作对象属性的机制， KVC(Key-Value-Coding)内部的实现：一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。KVO（Key-Value- Observing）：kvo 就是一个在语言框架层面实现的观察者模式 通过kvc的方式修改属性时，会主动通知观察者 </li>
<li>类别：具有更高的优先级，相当于扩展方法，你要在类上扩展一个其他方法可以使用这个<br>继承：继承可以增加，修改或者删除方法，并且可以增加属性。</li>
<li>代理的作用，是为了解耦，我告诉我的助理去做某件事，而不是我亲自去做</li>
<li>代理（一对一 has a所谓控制链）和通知（一对多）</li>
<li>响应链：相当于冒泡时间，点击后向下传递，（实现父类方法）再一层层往上传</li>
<li>selector和Method：一个名字，一个名字和实现的结合体</li>
<li>IMP就是实现方法</li>
<li>ASIDownloadCache 设置下载缓存</li>
<li>UIView本身更像是一个CALayer的管理器，一个UIView上可以有n个CALayer</li>
<li>而#import比起#include的好处就是不会引起重复包含</li>
<li>延展（extension）:在自己类的实现文件中添加类目来声明私有方法。另外后者添加的方法是必须要实现的。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/11/多线程/" class="article-date">
  	<time datetime="2015-05-11T15:19:35.000Z" itemprop="datePublished">5月 11 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多线程">多线程</h2><h3 id="NSThread">NSThread</h3><ol>
<li>需要管理线程的生命周期，<strong>获取当前线程</strong>线程对象[NSThread currentThread],num相当于线程id,</li>
<li><strong>获取主线程</strong>[NSThread mainThread]</li>
<li><strong>创建</strong>一个新线程:[]NSThread alloc] initWithTarget(id)对象 selectir ] 开始线程：thread start<br>方法2：[NSThread detachNewThreadSlector] 马上启动线程</li>
<li>隐氏创<strong>建线程</strong>[self  performSelectorInBackground]</li>
<li><strong>暂停</strong>线程<code>[NSThread sleepTimeInterval:2]</code><br>[NSThread untilDate:date]</li>
<li>在当前线程执行操作[self performselector] </li>
<li>在指定线程执行某个操作  [self performSelect:(sel) onTherad] waitUntilDone:No会马上返回</li>
<li>[self performSelectOnMainThread]  下载图片后返回到主线程[self.imageView performSelectorOnMainThread]</li>
<li>下载图片  进度条，imageview  imageView.contentMode  scaleAspectFit(保持原来的宽高比)</li>
<li></li>
</ol>
<h3 id="NSOperation">NSOperation</h3><ol>
<li>不需要考虑线程生命周期，同步，加锁等问题</li>
<li>将操作封装在NSOperation对象</li>
<li>把对象添加到NSOperationQueue中，<strong>设置依赖关系</strong></li>
<li>使用NSOperation的子类<br><strong>NSInvocationOperation</strong>:    [NSInvocationOperation alloc] initWithTarget:   调用autoRelease<br>启动操作[operation start]  默认是同步执行，在主线程中执行<br>监听完成操作，<code>operation.CompletionBlock=^{}</code>，执行完了之后调用</li>
</ol>
<p><strong>NSBlockOperation</strong>:[NSBlockOperation BlockOperationWithBlock] ,添加附加的操作， operation addExecutionBlock 并行执行，多个操作开启多个线程，并发执行<br>cancle取消某个操作</p>
<p><strong>自定义NSOperation</strong>  ：重载main方法 <code>-（void）main{ @autoRelease{ if(self.isCancled){ return } 下载图片 判断有没有被取消  }  }</code> 异步执行，main方法可能在其他线程调用，就不能访问主线程的自动释放池，新建一个属于当前线程的自动释放池<br>把对象传递给外面：1.代理  2. Block：  retain对Block没有作用，copy才有用<br>要在dealloc中作释放操作<br>_表示内部<br>属性不能跟父类重复</p>
<p>NSOperation<strong>Queue</strong>：当前方法在哪里调用，就在哪里执行<br> [Queue addOperation:]马上执行操作，不用调用Start，异步操作，做一次Retain操作   先加的就先执行<br> 添加一组<br> 添加依赖：addDependency  队列和队列中的操作之间也可以添加依赖（跨队列） 不能环形依赖<br> 限制并发操作数量：setMaxConcurentOperationCount<br> 取消所有操作[queue cancleallOperation]<br> [queue setSuspended:Yes]:暂停 正在进行不会暂停，执行完后才暂停<br> &lt;#可替换的代码块#&gt;</p>
<h3 id="GCD">GCD</h3><ol>
<li>定义好操作，添加到调度队列中</li>
<li>并行队列（并发执行），串行队列</li>
<li>全局并行队列dispath<em>get_globle_quque(,0)<br> 获取全局队列：<code>dispath_get_globle_quque</code><br> 异步并行：<code>dispath_get_globle_quque</code> <code>dispathc_async(quque,block)</code><br> 异步串行：手动创建：dispatch_quque_create(“xzr”,null) 开启异步任务 `dispathc</em><strong>async</strong><code>同步执行：</code>dispath<em>get_globle_quque<code>开启同步任务</code>dispathc</em><strong>sync</strong>`<br> 循环：dispatch_apply(次数，手动创建/并发队列)</li>
<li>获取跟主队列 dispatch_get_main_queue();dispatch_async()</li>
<li>开启异步任务去下载图片，把操作放到一个异步线程中去计算，  </li>
<li>依赖关系：组dispatch_group_async_crate()，并发执行 dispatch_group_async(group,queue,block)，一起执行完， dispatch_group_notify(group,main,block)</li>
<li>dispatch_releleas（组和Create的队列）</li>
<li>队列的类型只决定任务是并发还是串行，函数名称代表是异步还是同步</li>
</ol>
<h3 id="图片">图片</h3><ol>
<li>图像自动调整大小 <code>【self.imageView sizeToFit】</code></li>
<li>设置睡眠时间：<code>[NSThread sleepForTimeInterval:2]</code></li>
<li>获取当前线程<code>[NSThread CurrentThread]</code></li>
<li>在后台线程中(非主线程)执行:<code>[self performSelectInbackground:]</code>  不能自动回收线程，会建立大量的子线程。所以是<strong>不正确</strong>的，应该使用<code>[self performSelectOnMainThread]</code> waitUntiDone:YES阻塞当前线程，No不会</li>
<li>使用NSThread的线程，不会自动添加到自动释放池中，使用GCD和NSOpertation也会自动添加自动释放池，NSThread和NSobject不会，需要自己加autoReleasePool</li>
<li>缓存策略：使用0（会使用本地缓存）,1(忽视本地内存缓存)  206状态码：加载一部分</li>
<li>写入文件：追加文件 FileHandle （视5频的拖动播放） <code>fp seekToEndOfEnd</code>  <code>fp writeData</code></li>
<li>InlineBlock快捷代码 在主线程更新UI,回到主线程    <code>dispatch_get_main_queue()</code>   创建一个线程，<code>dispatch_queue_create(&quot;download&quot;,dispatch_queue_serial)</code> ,<code>dispatch_async(q,block)</code></li>
</ol>
<h3 id="上传">上传</h3><ol>
<li>post格式：content=”multipart/form-data”</li>
<li>put不支持浏览器操作<br>3.</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-文件下载" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/09/文件下载/" class="article-date">
  	<time datetime="2015-05-09T08:11:21.000Z" itemprop="datePublished">5月 9 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="文件下载">文件下载</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 swagon
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>