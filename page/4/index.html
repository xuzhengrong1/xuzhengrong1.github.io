<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>swagon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的代码很烂">
<meta property="og:type" content="website">
<meta property="og:title" content="swagon">
<meta property="og:url" content="yoursite.com/page/4/index.html">
<meta property="og:site_name" content="swagon">
<meta property="og:description" content="我的代码很烂">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="swagon">
<meta name="twitter:description" content="我的代码很烂">
  
    <link rel="alternative" href="/atom.xml" title="swagon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">swagon</a></h1>
		</hgroup>

		
		<p class="header-subtitle">原谅我不堪回首的过去</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">swagon</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">swagon</h1>
			</hgroup>
			
			<p class="header-subtitle">原谅我不堪回首的过去</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-mac操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/15/mac操作系统/" class="article-date">
  	<time datetime="2015-07-15T07:49:58.000Z" itemprop="datePublished">7月 15 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Mac操作系统">Mac操作系统</h3><ol>
<li>10.4.4 tiger开始入侵intel x86的地盘   ppc架构 x86架构</li>
<li>iOS内核和二进制编译的目标架构是arm架构，电源管理有优势</li>
<li>unix api darwin</li>
<li>按下空格键快速预览</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-禅与OC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/15/禅与OC/" class="article-date">
  	<time datetime="2015-07-15T02:35:41.000Z" itemprop="datePublished">7月 15 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题">问题</h2><ol>
<li>常量应该尽量使用 in-line 的字符串字面值或者数字，这样便于经常用到的时候复用</li>
<li>extern NSString *const ZOCCacheControllerDidClearCacheNotification;关键字的作用</li>
<li>如果 block 没有在其他地方被保持，那么它会随着栈生存并且当栈帧（stack frame）返回的时候消失。当在栈上的时候，一个 block 对访问的任何内容不会有影响。如果 block 需要在<strong>栈帧返回</strong>的时候存在，它们需要明确地被复制到堆上，这样，block 会像其他 Cocoa 对象一样增加引用计数。</li>
<li>如果一个 block指向一个栈变量或者指针，那么这个block初始化的时候它会有一份声明为 const 的副本，所以对它们赋值是没用的</li>
<li>复制之后栈上的以及产生的堆上的 block 都会引用这个堆上的变量。引用计数器为</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-熟悉objective-c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/14/熟悉objective-c/" class="article-date">
  	<time datetime="2015-07-14T07:48:05.000Z" itemprop="datePublished">7月 14 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="熟悉Objective-C">熟悉Objective-C</h2><p>使用消息结构的语言，运行时所执行的代码由运行环境决定，而使用函数调用的语言，由编译器决定。<br>尽量减少引入头文件<br>@class只能告诉你有个这个类，不能告诉你类里面有什么</p>
<p>字面量数组比按常规创建的数组的语法要安全，遇到nil会报错，但是如果用常规方法的话，如果1，3有值，第二个元素为Nil，那么创建出来的数组元素只有第一个元素，会<strong>丢失数据</strong></p>
<p><strong>字面量字典</strong><br>字符串，数组，字典对象都是不可变的，但是要可变就要复制一份<br><strong>多用类型常量，少用#define</strong><br>define没有类型，重复定义不会报错<br>如果文件局限于.m文件，则在常量前面加K，在类之外也可看到就加前缀<br>常量名称，为了避免命名冲突，所以加上类型作为前缀</p>
<h3 id="属性">属性</h3><p>属性用于封装数据<br>语义：copy<br>在对象内部读取数据时，应该直接通过实例变量来读，写入数据时，通过属性来</p>
<h3 id="实例变量">实例变量</h3><ol>
<li>声明 @interface MainController {<br>  ASIHTTPRequest *request;<br>}</li>
</ol>
<h3 id="理解objec_msgSend">理解objec_msgSend</h3><ol>
<li>步骤：[someObject messageName:parameter]=void objec_msgSend(id self,sel cmd,…)  在方法列表中找，如果能找到，就执行，如果不能找到就往上找，最终找不到，就调用messaggeForWarding</li>
<li>缓存（fast map）每个类都有这样一块缓存</li>
<li>objc_msgSend_stret,objec_msgSend_fpret</li>
<li>消息转发过程<code>reolveInstanceMethod-&gt;forwardingTargetForSelector(备援)-&gt;forwardInvocation</code><h3 id="方法混写">方法混写</h3>每个方法对于相对的实现，我们可以交换方法的实现<br>方法混写滥用会造成代码不易懂和难以维护<h3 id="类对象">类对象</h3>消息的接受者究竟是神马？<br>oc对象实例是指向某块内存的指针，变量会指向该实例<br>kind代表一种（有继承），member代表成员<br>类对象是单例<h3 id="实现description">实现description</h3></li>
</ol>
<h3 id="理解NSCopying">理解NSCopying</h3><h3 id="prorocol：声明一些方法，相当于接口（代理模式，观察者模式）">prorocol：声明一些方法，相当于接口（代理模式，观察者模式）</h3><ol>
<li>&lt;&gt;遵守协议，：实现继承 ()分类   {}字典 （）可以是数组</li>
<li>基协议：类似继承，基类会遵守基协</li>
<li>要求对象遵守自定义协议，NSObject<myprotocol></myprotocol></li>
<li>属性必须遵守某个协议  id<myprotocol> obj,成为属性也要遵守协议</myprotocol></li>
</ol>
<h3 id="分类">分类</h3><p>@interface Person(Add)</p>
<p>提供类方法快捷访问<br>分类会覆盖原类的方法：</p>
<h3 id="NSMutableString">NSMutableString</h3><ol>
<li>继承NSString 可变字符串可以在字符串对象的内容  增加和删除，删除是从零开始的</li>
<li>rangeOfString,获取在字符串的位置（删除固定的字符串）</li>
<li>NSArray(集合类),ocs数组只能存放oc对象，不能存放非OC对象，nil是数组元素结束的标记，编译器特性@[]</li>
<li>NSSet:没有顺序的</li>
<li>关键字以@开头</li>
<li>先把类加载到内存</li>
<li><em>str str代表内存空间地址  </em>str代表找到对应的存储空间  &amp;str是str的地址  **str代表地址<h3 id="裁剪">裁剪</h3></li>
<li>MasksToBounds(clipToBounds):方法告诉layer将位于它之下的layer都<strong>遮盖住</strong></li>
<li>views是独立的，内部细节是不需要让控制器知道的</li>
</ol>
<h3 id="UIContentMode中的fill和_fit_aspect">UIContentMode中的fill和 fit  aspect</h3><ol>
<li>fill相当于是横屏(相当于去横屏进行缩放)； //房间里很快挤满了人 （横向的）</li>
<li>fit相当于是竖屏(相当于去竖屏进行缩放)；  //That jacket fits well. 衣服是一个竖向的东西</li>
<li>aspect是等比,ASPECT RATIO 画面比例影像放映在银幕上的纵横（高宽）比例。</li>
<li>记录代码的运行时间<code>#define TICK   NSDate *startTime = [NSDate date] #define TOCK   NSLog(@&quot;Time: %f&quot;, -[startTime timeIntervalSinceNow])</code></li>
<li>Antialia  self.layer.allowsEdgeAntialiasing = YES;//反锯齿</li>
<li>修复xcode 插件失效<br>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info.plist DVTPlugInCompatibilityUUID</li>
<li><a href="http://qiufeng.me/xcode-format%20copy/" target="_blank" rel="external">clangformat 插件修改</a> 重命名vm 改名字为系统禁止改的形式，要用终端</li>
</ol>
<h3 id="nil和NULL">nil和NULL</h3><ol>
<li>NSURL <em>url = nil；<br>Class class = Nil；<br>int </em>pointerInt = NULL；<br>nil是一个对象指针为空，Nil是一个类指针为空，NULL是基本数据类型为空。<h3 id="Unsafe_unretained_=_assgin">Unsafe_unretained = assgin</h3></li>
<li>对应基本数据类型<h3 id="copy">copy</h3></li>
<li>当某个属性是指向其他对象的指针，而且改对象的类有可修改的子类，应该设置为copy(只有可变对象才要用Coopy)  <a href="http://v.youku.com/v_show/id_XOTMwMjcwNTgw.html?f=23636745&amp;from=y1.2-3.4.17" target="_blank" rel="external">视频</a></li>
<li>copy <strong>语法是创建一个副本，改变对象不影响原来的对象</strong>  string array dictionary copy产生的都是不可变   mutableCopy产生的都是可变</li>
<li>调用string copy 并没有产生一个新的对象 在这里copy就相当于retian  ,不可变变成不可变才是浅拷贝，其余都是深度拷贝   Mutable对象 MutableCopy都是深拷贝</li>
<li><p>`  NSString *str=@”111”;<br>p.name=str;</p>
<p>str=@”222”;<br>NSLog(@”%@”,p.name); ///111<br>NSLog(@”%@”,str); ///222`</p>
<h3 id="自动释放池">自动释放池</h3></li>
<li>不使用alloc init创建的对象，一般放在自动释放池里管理</li>
<li>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</li>
<li>AutoreleasePoolPage</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小）</li>
<li>释放是由高向低进行释放，所以Autorelease Pool嵌套，不会有影响</li>
</ol>
<h4 id="uiimage和imageWithContentsOfFile">uiimage和imageWithContentsOfFile</h4><ol>
<li><1>+imageNamed：该方法使用系统缓存，适合表视图重复加载图像的情形。同时该API根据UIScreen的scale，自动查找包含对应高倍图后缀名（@2x）的文件，如果没找到设置默认image.scale=1.0。因此，使用该方法，无需特意指定高倍图后缀。在实际运行时，系统如果发现当前设备是Retina屏（scale=2），会自动寻找”*@2x.png”命名格式的图片，加载针对Retina屏的图片素材，否则会失真。<ol>
<li><2>+imageWithContentsOfFile/+imageWithData:(scale:)/-initWithContentsOfFile:/-initWithData:(scale:)<br>这组方法创建的UIImage对象没有使用系统缓存，并且指定文件名必须包含明确的高倍图后缀。如果文件名包含@2x后缀，则image.scale=2.0；否则默认image.scale=1.0，同样对于Retina屏将会失真。</2></li>
</ol>
</1></li>
</ol>
<h4 id="loadView/viewDidLoad/initWithNibName/awakeFromNib/initWithCoder的用法">loadView/viewDidLoad/initWithNibName/awakeFromNib/initWithCoder的用法</h4><p>大前提是UIViewController有一个UIView.同时,需要厘清两个概念,创建一个类和实例化一个类.在XCode中创建一个类和实例化一个类很容易区分,但是在IB(Interface Builder)中有时候就会迷糊.其实也很好区分,孤零零地创建了一个nib文件,没有和其他可被实例化的类有直接或间接关系的时候,这个类或这些类(一个nib文件俺也可能包含多个类)是没有机会被实例化的,所以这种情况只是通过ib创建了一个类,而没有实例化.真正的实例化还需要通过在Xcode用代码来读取这个nib文件.知道这两这的区别后这些方法也就容易辨认多了 </p>
<p>viewDidLoad其实没什么可混淆的,无论通过什么途径加载(Xcode或者IB,这里的加载属于实例化)完view后肯定会执行这个方法. </p>
<p>loadView需要分两种情况.当你通过Xcode实例化一个类的时候就需要自己在controller中实现这个方法.而在IB中实例化就不需要实现它. </p>
<p>initWithNibName这个方法是在controller的类在IB中创建,但是通过Xcode实例化controller的时候用的. </p>
<p>awakeFromNib这个方法是一个类在IB中被实例化是被调用的.看了帖子发现大家都推荐使用viewDidLoad而不要使用awakeFromNib,应为viewDidLoad会被多次调用,而awakeFromNib只会当从nib文件中unarchive的时候才会被调用一次.实际测试中发现,<strong>当一个类的awakeFromNib被调用的时候,那么这个类的viewDidLoad就不会被调用了</strong>,这个感觉很奇怪. </p>
<p>initWithCoder是一个类在IB中创建但在xocdde中被实例化时被调用的.比如,通过IB创建一个controller的nib文件,然后在xocde中通过initWithNibName来实例化这个controller,那么这个controller的initWithCoder会被调用. </p>
<p>如果你的对象是UIViewControler的子类，那么你<strong>必须调用</strong>- (id)initWithNibName:(NSString <em>)nibNameOrNil bundle:(NSBundle</em>)nibBundleOrNil;方法去调用NIB文件初始化自身，即使那没有使用nib文件也会调用这个函数（默认情况下init方法已经为你的做这件事情了），如果你调用这个方法，并传递的两个参数为空（nil），然后类会调用-loadView去读取一个名字和你的UIViewController名字相同的nib文件，来初始化自身。如果没有这样的nib文件，你必须调用-setView:来设置一个self.view。或者重载-loadView 方法 </p>
<p>（2）<strong>initWithCoder: &amp; initWithFrame:</strong><br>initWithCoder：使用文件加载的对象调用（如从xib或stroyboard中创建）<br>initWithFrame：使用代码加载的对象调用（使用纯代码创建） <strong>init会调用这个函数</strong><br>注意：所以为了同时兼顾从文件和从代码解析的对象初始化，要同时在initWithCoder: 和 initWithFrame: 中进行初始化</p>
<p>viewDidLoad,就是view加载完毕之后就会调用，无论手写还是xib</p>
<p>initwithNibName-&gt;loadView(只负责从XIB中加载，但是如果你重写这个就可以用你自己的代码)-&gt; viewDidLoad 这个顺序</p>
<p>initWithNibName:<strong>半代码化初始</strong>时使用. 完全IB化初始时不调用,UIViewController代码化初始时会通过init调用,<strong>且调用在[super init]中</strong>.（这是为什么要调用Super init 的原因之一）<br>调用顺序: super init-&gt;initWithNibName(其实在super init中) -&gt;init after self created-&gt;loadView-&gt;ViewDidLoad</p>
<p>在遍历的时候，使用<strong>strong修改正在遍历的值<br>Fast enumeration variables can’t be modified in ARC by default; declare the variable </strong>strong to allow this<br>Rationale<br>This is an optimization made possible because fast enumeration loops promise to keep the objects retained during enumeration, and the collection itself cannot be synchronously modified. It can be overridden by explicitly qualifying the variable with __strong, which will make the variable mutable again and cause the loop to retain the objects it encounters.</p>
<h4 id="clipsToBounds和masksToBounds">clipsToBounds和masksToBounds</h4><h4 id="_deleteButton-currentImage-size-width">_deleteButton.currentImage.size.width</h4><h4 id="layoutSubviews">layoutSubviews</h4><p>在5.1之前什么都不做，除此之外<br>the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>
<p>而且，layoutSubviews 方法只能被系统触发调用，程序员不能手动直接调用该方法</p>
<p>Stackoverflow 上已经有相关的讨论了（作者在他的博客上有更详细的描述），并且有一位朋友给出了很不错的解答：</p>
<p>init does not cause layoutSubviews to be called (duh)<br>addSubview causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target<br>view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different<br>scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview<br>rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)<br>Resizing a view will call layoutSubviews on its superview<br>也就是说，layoutSubviews 方法会在这些情况下，在这些 UIView 实例上被调用：</p>
<ol>
<li>addSubview 被调用时：target view（一定会），以及被添加的 view（第一次调用会）</li>
<li>更改 UIView 的 frame 时：被更改 frame 的 view（frame 与之前不同时）</li>
<li>对于 UIScrollView 而言，滚动式：scroll view</li>
<li>设备的 orientation 改变时：涉及改变的 UIViewController 的 root view</li>
<li>使用 CGAffineTransformScale 改变 view 的 transform 属性时，view 的 superview：被改变的 view<br>总结：</li>
<li>第一次调用 addSubview 的时候，target view 和被添加到 target view 的 view 的 layoutSubviews 方法会被调用。在已经添加完毕后，若 target view 已经拥有该被添加 view，则只有 target view 的 layoutSubviews 方法会被调用。“and all the subviews of the target”这句话是错误的。</li>
<li>只有 UIView 处于 key window 的 UIView 树中时，该 UIView 的 layoutSubviews 方法才有可能被调用。不在树中的不会被调用。这也是为什么 Stackoverflow 上的讨论中这个答案的第二点会被提出。</li>
</ol>
<p>能做的三件事<br>Adjust the size and position of any immediate subviews.<br>Add or remove subviews or Core Animation layers.<br>Force a subview to be redrawn by calling its setNeedsDisplay or setNeedsDisplayInRect: method.<br>//应用程序经常重新布局子视图，当使用一个大的ScrollView<br>发生滚动事件，根视图 setNeedsLayout-&gt;setNeedsLayout重新布局，当视图片滚出可视范围，layoutSubView 移动新的视图到进入的边缘，替换掉原来的视图<br>layoutSubView方法</p>
<h4 id="Composite_Pattern">Composite Pattern</h4><h4 id="__bridge">__bridge</h4><p>还可以通过 __bridge 转换让局部变量持有返回对象</p>
<h4 id="你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。">你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。</h4><p>因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的</p>
<p><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">分类</a></p>
<h4 id="inLine关键字">inLine关键字</h4><p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。<br>inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。</p>
<p>inline函数仅仅是一个建议,对编译器的建议,所以最后能否真正内联,看编译器的意思,它如果认为函数不复杂,能在调用点展开,就会真正内联,并不是说声明了内联就会内联,声明内联只是一个建议而已.<br>其次,因为内联函数要在调用点展开,所以编译器必须随处可见内联函数的定义,要不然,就成了非内联函数的调用了.所以,这要求每个调用了内联函数的文件都出现了该内联函数的定义。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/10/基础知识/" class="article-date">
  	<time datetime="2015-07-10T08:25:08.000Z" itemprop="datePublished">7月 10 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基础知识">基础知识</h2><h3 id="单例">单例</h3><p>+(XXXManager <em>)sharedInstance<br>{<br>    static XXXManager </em>sharedManager;</p>
<pre><code><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
    sharedManager = [[XXXManager alloc] init];
});

<span class="keyword">return</span> sharedManager;
</code></pre><p>}</p>
<h3 id="方法废弃">方法废弃</h3><p><code>+ (MWPhoto *)photoWithFilePath:(NSString *)path  __attribute__((deprecated(&quot;Use photoWithURL: with a file URL&quot;)));</code></p>
<h4 id="向类或者是实例发送消息">向类或者是实例发送消息</h4><ol>
<li>不论是实例对象还是Class，都是id类型的对象（Class同样是对象）</li>
<li>实例对象的isa指向它的Class（-储存所有减号方法）,Class对象的isa指向<strong>元类</strong>（+储存所有加号方法）</li>
<li>向一个对象（id类型）发送消息时，都是从这个对象的isa指针指向的Class中寻找方法</li>
<li>由于objc对这块的设计是，<strong>NSObject的元类的父类是NSObject类</strong>（也就是我们熟悉的NSObject类），其中有所有的实例方法，因此找到了- responseToSelector</li>
</ol>
<p>实例方法是一条线，类方法是另外一条线</p>
<h4 id="view的懒加载">view的懒加载</h4><p>我们知道，ViewController的view初始化大概流程是：</p>
<ul>
<li>(UIView <em>)view<br>{<br>if (!_view) {<br>  [self loadView];<br>  [self viewDidLoad]; //<br>}<br>}<br>所以在外部执行到vc.view.frame = CGRectMake(0, 0, 100, 100);这句话时，在赋值操作执行前，viewDidLoad就已经被调用，因而在viewDidLoad中对view frame的取值都是默认值（window的大小），而非设定值。 <em>*懒加载问题</em></em></li>
</ul>
<p>dispatch_sync调用结束执行block    block执行完才能继续回到调用点</p>
<p>dispatch_sync在等待block语句执行完成，而block语句需要在主线程里执行，所以dispatch_sync如果在主线程调用就会造成死锁</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-lldb" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/09/lldb/" class="article-date">
  	<time datetime="2015-07-09T09:33:42.000Z" itemprop="datePublished">7月 9 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="lldb">lldb</h3><ol>
<li><strong>frame variable</strong>查看程序当前状态下所有变量的值</li>
<li>po item</li>
<li><strong>bt</strong> 查看程序运行的调用栈</li>
<li>frame variable *self</li>
<li>image命令的用法也挺多，首先可以用它来查看工程中使用的库，image list</li>
<li>找到错误(lldb) image lookup —address 0x0000000100000de0</li>
<li>cmd+k快速清除log信息</li>
<li>pviews查看视图层级</li>
<li>border 0x79ec3140 -c green -w 2 加边框</li>
<li>pinternals 这个命令就是打印出来的一个控件（id）类型的内部结构，</li>
<li>presponder 打印出一个集成于UIResponder控件的消息传递链。</li>
<li>pclass pclass可以打印出一个对象的继承关系。</li>
<li>taplog 这个命令是模拟敲击一下屏幕，并且打印出你敲击屏幕时候事件接收的对象</li>
<li>visualize 可以使用mac下的预览app打开我们的图片UIImage, CGImageRef格式的图片，甚至view和layer的图片 。visualize 0x79ec3140//或者变量名，此地址是id类型的</li>
<li><strong>hide&amp;show</strong> hide命令可以直接隐藏一个对象,移除当前遮挡的对象便于你观察后面的对象。show命令会让它再次显示出来</li>
<li>vs，fv,fvc，这几个命令都需要正则表达式的知识背景</li>
<li><strong>pvc</strong>这个命令的作用是打印出当前的控制器层级</li>
<li><img src="http://m3.img.srcdd.com/farm4/d/2015/0212/13/E505902B1D8D75A1B63C5611BF482417_ORIG_1490_964.gf" alt="po"></li>
<li>p是打印非对象的值</li>
<li>po [[self view] recursiveDescription]</li>
<li>expr — (void) printf(“[%s %s]\n”, (char <em>)object_getClassName(</em>(long<em>)($esp+4)), </em>(long *)($esp+8))</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-autolayout" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/06/autolayout/" class="article-date">
  	<time datetime="2015-07-06T07:09:02.000Z" itemprop="datePublished">7月 6 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AutoLayout">AutoLayout</h2><h4 id="三种约束情况">三种约束情况</h4><ol>
<li>固定左右和顶部，等宽高</li>
<li>固定顶，左，宽高固定</li>
<li>中心 顶部 宽度 高度</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/29/问题/" class="article-date">
  	<time datetime="2015-06-29T08:30:56.000Z" itemprop="datePublished">6月 29 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="问题">问题</h2><ol>
<li>implicit declaration of function ‘NSApplicationMain’ is invalid in C99  解决方案： 导入 #import <cocoa cocoa.h=""> </cocoa></li>
<li>@import Foundation 和#import</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-coretext" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/29/coretext/" class="article-date">
  	<time datetime="2015-06-29T01:38:35.000Z" itemprop="datePublished">6月 29 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CoreText">CoreText</h2><h3 id="字符（Character）和字形（Glyphs）">字符（Character）和字形（Glyphs）</h3><p><a href="http://geeklu.com/2013/03/core-text/" target="_blank" rel="external">coreText入门</a></p>
<ol>
<li>Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的</li>
<li>Corec Text，将需要显示的<strong>文本内容，位置，字体，字形</strong>直接传递给(<strong>Core Graphics</strong>)Quartz</li>
<li>关于static inline 用在循环中会有显著的效果  push and pop things on/off the stack like parameters and the return address</li>
<li>As to advantages, if you are calling a small function from a loop then it can make a significant difference in performance.</li>
<li><a href="http://www.brighttj.com/ios/use-coretext-make-typesetting-picture-and-text.html" target="_blank" rel="external">ss</a></li>
<li>这三句话的理解// 步骤2：翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0））<br>CGContextSetTextMatrix(context, CGAffineTransformIdentity);<br>CGContextTranslateCTM(context, 0, self.bounds.size.height);<br>CGContextScaleCTM(context, 1.0, -1.0);</li>
<li>在配置NSMutableAttributedString 的Attribute的时候，用到了很多这样的(__bridge id)标识，来解释下：这个因为addAttribute:是OC的方法，需要Object C 对象，而CTParagraphStyleRef这些是由C语言实现的Core Foundation Framework 框架中的对象，这两种类型可以相互转换和操作。Core Foundation Framework 框架中的对象也有引用计数的概念，但是不是Cocoa Framework中的release/retain不同，而是使用自身的CFRetain/CFRelease接口，</li>
<li>CFAttributedStringRef ：属性字符串，用于存储需要绘制的文字字符和字符属性<br>CTFramesetterRef：通过CFAttributedStringRef进行初始化，作为CTFrame对象的生产工厂，负责根据path创建对应的CTFrame<br>CTFrame：用于绘制文字的类，可以通过CTFrameDraw函数，直接将文字绘制到context上<br>CTLine：在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行<br>CTRun：每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本</li>
<li>CoreText相对于webView占用少的内存</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-学会看xcode文档" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/26/学会看xcode文档/" class="article-date">
  	<time datetime="2015-06-26T03:13:38.000Z" itemprop="datePublished">6月 26 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学会看Xcode文档">学会看Xcode文档</h2><p>前面我们讲Xcode的文档结构是在介绍如何能够快速定位到你要找的内容。但是很多人的问题可能是一开始就根本不知道要读什么。</p>
<p>这里我们就介绍自学iOS开发应该遵循或者说我们推荐的必读文档的阅读顺序。</p>
<p>阅读顺序：</p>
<p>《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》<br>《Your First iOS App》<br>《Your Second iOS App: Storyboards》<br>《Your Third iOS App: iCloud》<br>《iOS Technology Overview》<br>《iOS Human Interface Guidelines》<br>《    》和《Programming with Objective-C》<br>《iOS App Programming Guide》<br>《View Programming Guide for iOS》和《View Controller Programming Guide for iOS》<br>《Table View Programming Guide for iOS》<br>首先应该看的是Getting Started里面的《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》（中英文版本皆有，苹果官方的翻译）。这个文档讲的很浅，但是是建立概念的文档，你以后在开发里面经常遇到的概念，在这里都有包含，特别注意是，这个文档看起来简单，但是每页下面的相关文章，不是选读，都是必读。</p>
<p>即使是很多做了iOS开发很久的同学，其实也有很多概念上的误解，现代程序开发越来越简单，工具越来越强大，往往有些误解也可以继续前行，但是实际上不建立扎实的基础是很吃亏的，往往后面理解和解决一个不难解决小问题都要付出很多辛苦。</p>
<p>阅读这个文档的目的和检测标准是，以后你看到iOS开发中的基本概念，都大致所有了解。</p>
<p>读完《马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)》后，应该去看Your XXX iOS App系列这个系列不是什么很难的文章，你也不必着急先去学习Objective-C，学什么C语言就更不要着急。我推荐的学习方法是有成就的逐步学习法。在学习系统体系架构、Objective-C之前，你可以先按照文档写一个全天下最简单的App，完成学习过程中第一个里程碑。在这个过程中不用担心有什么疑问，有什么不懂，先照着做就是。</p>
<p>阅读这三个文档的目的和检测标准是，把这三个Demo App做出来在模拟器上跑起来。</p>
<p>在这个过程中，你对开发工具的基本认识就建立起来了，也有了成就感，去了魅（就是消除了对iOS开发的神秘感）。</p>
<p>再往下，建议你去看《iOS Technology Overview》（iOS技术概览），iOS不是一个技术，而是一堆技术，前一篇讲到文档导航区域的分类，框架分类的时候，我说不细讲的原因就在于此，你要做一个动画应该用Core Animation还是OpenGL？你要做一些文本相关操作应该用Core Text还是什么，就是看这里。</p>
<p>学习现代的程序开发，语言和框架并重。我们Tiny4Cocoa叫做这个名字的原因就是，iOS/Mac开发者的代表往往就是这个Cocoa框架，就是这个SDK。大多数你所需要的功能都躺在框架里面，你知道框架的结构，你才知道怎么去寻找相关的技术资料。</p>
<p>阅读这个文档的目的和检测标准是，遇到具体问题，知道应该去看哪方面的文档。</p>
<p>再下来，建议阅读的是《iOS Human Interface Guidelines》，Mac/iOS平台虽然也是百花齐放各类程序、App都有，但是总体看来，大多数优秀App的UI看起来都和整个系统很协调。这和Windows以及很多其他平台完全不同。这是为什么呢？</p>
<p>很大程度就归功于《Human Interface Guidelines》文化，所谓Human Interface Guidelines就是用户界面的规范，在苹果它还专门有一个缩写叫做HIG，是天条一样的东西。所有的App都推荐遵循HIG，遵循了HIG，你做的东西用户看起来就会觉得和整个系统很协调。即使是你要做一些创新的设计，你势必会打破HIG的限制，但是你这个时候仍旧应该遵循HIG的精神。</p>
<p>此外，你阅读HIG的很重要一点是了解整个UI结构和UE行为的逻辑机理，这样才能在你设计界面的时候有所依据。</p>
<p>阅读这个文档的目的和检测标准是，看到任何一个App，你可以知道它的任何一个UI是系统控件，还是自定义控件，它的层次关系等等。</p>
<p>《Learning Objective-C: A Primer》是非常初级和简单的入门，适合先阅读。《Programming with Objective-C》超微复杂一点点，适合后阅读。</p>
<p>一般人建议先学习语言，我反之建议先做了一个App，然后再学习语言。原因有几个，首先现代开发工具，往往不是用来开发控制台程序的，上来就会有框架，光懂语言不会使用IDE，甚至可能会更麻烦。再其次就是，其实现代语言发展到了面向对象以后，库往往比语言更复杂，更重要，或者说更多的时候，我们是在学习库，而不是语言，语言只是库的一个载体。</p>
<p>比如，Delegate和Block等等都和Cocoa的UI异步机制关系紧密，光看代码，这些语言元素非常难以学习，也完全不知道其意义在哪里。</p>
<p>阅读这个文档的目的和检测标准是，看得懂基本的Objective-C代码，方便后面的学习和阅读各种示例代码。</p>
<p>《iOS App Programming Guide》基本上介绍的就是开发一个App的完整流程，包括App的生命周期、休眠、激活等等，里面介绍的细节颇多。正式开发第一个上线的App之前必看。或者开发了一个App，临到提交前必看才文档。</p>
<p>阅读这个文档的目的和检测标准是，了解全部流程和很多细节问题。</p>
<p>《View Programming Guide for iOS》和《View Controller Programming Guide for iOS》非常重要。View是整个图形界面里面最重要的概念。所有的图形、界面绘制都基于View。你看到的一切复杂的用户界面，就是各种不同的View的组合堆叠。</p>
<p>View Controller是View和某种逻辑在一起的组合，本质上这种组合不是必须的，但是是大大降低编程复杂度的一种设计。很多人不懂什么是View什么是View Controller，这样写起代码来就很痛苦。</p>
<p>阅读这个文档的目的和检测标准是，深刻理解什么是View，什么是View Controller，理解什么情况用View，什么情况用View Controller。</p>
<p>UITableView是最重要的一个控件，是最常用的UI界面元素。在UICollectionView出现之前，大量的内容列表展示的自定义控件都是基于UITableView，比如很多书架、图片Grid其实都是UITableView做的。</p>
<p>所以《Table View Programming Guide for iOS》非常重要，一定要好好阅读。</p>
<p>阅读这个文档的目的和检测标准是，深刻理解UITableView／UITableViewController的理论和使用方法。</p>
<p>我推荐的必读文档就这么多，仔细看的话，最多也就是今天就看完了。学习一个东西，如果有一点点耐心，有正确的方法其实不难，不是说脑子非要很聪明，大多数人都可以做到一个星期就学会iOS开发，其实就是读完这些文档，大多数人就会了。</p>
<p>就像我强调了无数次，阅读英文文档不难，我自己从当年看英文文档非常吃力，必须查词典开始，认真的看英文文档，不会就查词典，一个多月过去，读英文文档就完全不需要查词典了。</p>
<p>我们公司主程 @sycx 老师，也说他原来英语也很不好，甚至现在英语仍旧很烂，但是看英文文档完全没有问题，也就是几个星期的认真学习以后就突破了。</p>
<p>其实学习iOS也如此。当然我不是说你看懂这10组文档就再也不用看别的了。而是说，如果你看懂了这10组文档，你就从初学者，或者是虽然会写一些程序，但是对iOS其实还不懂的状态，变成了一个入门者。</p>
<p>我不希望这个文章可以一句一句的帮你学会iOS是什么，这个文章的目的是帮你快速入门。一旦你入门了，你再遇到问题该看什么，你就不需要我讲了，你自己就知道了。一旦入门了，你就会发现，Xcode里面别的文档讲的内容虽然不同，但是结构你已经很清楚了，你学习起来很方便。<br><strong><br>阅读本文的目的和检测标准是，遇到问题，知道看什么文档，想提升自己技术的时候，知道按照什么脉络自己组织阅读</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-view_programing_guide_for_ios" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/26/view_programing_guide_for_ios/" class="article-date">
  	<time datetime="2015-06-26T03:06:59.000Z" itemprop="datePublished">6月 26 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="view_programing_guide_for_iOS">view programing guide for iOS</h2><ol>
<li>window没有可视区域，但是它提供了一个容器，view是window的一部分，你可以往里面添加内容，你也可以使用视图管理其他视图。  view也可以作为一个容器</li>
<li>每个程序至少有一个window和一个view用来显示内容,uikit和其他框架提供预定好的视图用来显示内容,如果不满足要求，我们可以自定义view处理</li>
<li>view是uiview的实例，管理一个长方形的区域在应用程序中</li>
</ol>
<h2 id="视图管理_你应用的可视区域">视图管理 你应用的可视区域</h2><ol>
<li>在视图层级中，父视图是用来放置和规定子视图的大小，动态修改子视图大小，比如旋转和动画的时候；    </li>
<li>构建视图就像砌砖块一样的构建用户界面，而不是用一个view去展示所有的内容，你经常用很多视图去构建一个视图层级，每个view都是一个特殊的部分在你的界面中，通常优化一个类型的内容，比如uikit,有专门的视图，用来展示图片，文字，和其他类型的内容</li>
</ol>
<h3 id="Window调节view的显示">Window调节view的显示</h3><p>window处理所有的用户界面的展示，window通过view来工作，<br>Windows work with views (and their owning view controllers) to manage interactions with, and changes to, the visible view hierarchy，大部门时间，window是不会改变的，一旦创建，他保持着一样，<br> it stays the same and only the views displayed by it change，<br> 每个应用程序至少有一个window来显示用户界面，和设备的的主屏幕，如果一个额外的展示链接到设备中，可以创建第二个window在那个屏幕上</p>
<h3 id="动画给用户可视的界面反馈">动画给用户可视的界面反馈</h3><ol>
<li>动画给用户可视的反馈，体现在视图层次的改变，系统定义了基本的动画，展现一个模态视图，在不同的视图组之间过渡，然而很关于view的属性也可以直接动画，比如，你可以改变视图的透明度，他在屏幕中的位置，他的尺寸，他的背景颜色，或者其他属性。如果你直接用view底层的核心动画对象，你可以展现许多其他的动画。</li>
</ol>
<h3 id="IB的角色">IB的角色</h3><ol>
<li>IB是一个应用程序，你可以用来以图像的方式构建和配置你应用程序的windows和view,使用IB，你可以组装自己的视图和对象，当你在运行时加载一个nib文件，里面的对象会被重新构建到实际的对象，你的代码可以操作他们</li>
<li>IB极大的简化了你创建用户界面的工作</li>
</ol>
<h3 id="视图的结构">视图的结构</h3><ol>
<li>一个tar button item 本身不是一个视图，但是内部管理了一个视图</li>
<li>绘制代码严重影响性能，能少些就少写，代码被调用，会被缓存起来重复利用，重用生成好的代码，排除昂贵的画循环，通常需要更新视图。重用这些内容，在动画期间非常重要，就是存在的内容可以被操作的时候，这样的重用，相比创建一个新的内容，会 less expensive</li>
</ol>
<h3 id="视图的结构-1">视图的结构</h3><ol>
<li>子视图被放在一个数组中，被放置的顺序影响视图的可见性，如果两个同级的视图重叠，后添加的会再前面添加的顶部</li>
<li>数组的顺序也会影响到程序如何响应事件，响应链是一级一级向父类传递</li>
<li>如果没有响应，最终会传递到application对象，这个对象，通常会丢弃他</li>
</ol>
<h3 id="view的画循环">view的画循环</h3><ol>
<li>定需求的画模型来决定视图的显示，如果你没有改变视图的内容，系统会捕捉内容的快照来显示视图的可视区域，那么画的内容就永远不会被再调用，快照图像重用于大多数操作涉及的视图</li>
<li><p>如果改变了内容，你通知系统视图改变，视图重复绘图的步骤，然后捕捉结果的快照</p>
</li>
<li><p>你使用setNeedsDisplay 和 setNeedsDisplayInRect: method是视图无效，这些方法告诉视图内容已经被改变，需要重绘在下一个时机。系统会等到当前运行循环结束后才会开始绘制。这个延迟给你机会去让视图失效，增加或者移除从视图层级中，重置视图大小，所有这些操作在同一时间</p>
</li>
<li>改变视图的几何形状不会导致视图重绘，在view的边界中，大多数内容拉伸，重新定位。</li>
</ol>
<h3 id="content_modes">content modes</h3><p>UIViewContentModeRedraw会重绘，强制调用drawrect,我们应该避免，在系统的视图中应该不使用他</p>
<h3 id="Stretchable_Views">Stretchable Views</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 swagon
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>